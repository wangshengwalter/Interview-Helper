Question,Answer
C++ lamda表达式有哪两种捕获方式,"捕获值的方式分两种，一种是按值捕获，一种是按引用捕获。按值捕获是不改变原有变量的值，按引用捕获是可以在Lambda表达式中改变原有变量的值。
[捕获值列表]:

1、空。没有使用任何函数对象参数。
2、=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。
3、&。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。
4、this。函数体内可以使用Lambda所在类中的成员变量。
5、a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。
6、&a。将a按引用进行传递。
7、a, &b。将a按值进行传递，b按引用进行传递。
8、=，&a, &b。除a和b按引用进行传递外，其他参数都按值进行传递。
9、&, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。"
Qt绑定信号槽有几种方式,"直接连接（Direct Connection）：直接连接会在发射信号时直接调用槽函数，这种连接方式是同步的。如果信号和槽函数运行的时间较长，可能会导致界面卡顿。因此，应该避免在主线程中使用此连接方式。
自动连接（Auto Connection）：Qt 会根据信号和槽函数的参数自动选择连接方式；如果信号和槽函数的参数类型一致，则使用直接连接，否则使用队列连接（Queued Connection）。
队列连接（Queued Connection）：队列连接是一种异步的连接方式，槽函数会被放入一个事件队列中，等待主循环处理。这种连接方式适用于多线程环境，因为槽函数会在主线程中执行，不会影响界面的响应。
拦截连接（Blocking Connection）：拦截连接是一种阻塞的连接方式，槽函数会在信号发射时立即执行，直到槽函数执行完毕后，信号才会继续传递给其他连接。
"
Windows异常处理和C++异常处理有什么区别,"https://zhuanlan.zhihu.com/p/382909501
和C++的try...catch...catch...不同，SEH中__try只能要么和一个__except搭配，要么和一个__finally搭配，不能同时出现多个__except或同时出现__except和__finally。"
C++ dynamic_cast是在什么时期进行类型转换的,"用于将一个指针或引用强制转换为另一个类型的指针或引用。
dynamic_cast 转换的步骤：
** 检查源指针或引用是否为 NULL**，如果是，直接返回 NULL 或抛出 std::bad_cast 异常。
检查目标类型是否与源类型兼容，如果不兼容，直接返回 NULL 或抛出 std::bad_cast 异常。在向下转型时，目标类型必须是派生类类型的指针或引用；在向上转型时，目标类型必须是基类类型的指针或引用。
进行类型转换。在向下转型时，编译器会利用对象的类型信息和虚函数表指针来计算出派生类对象的地址；在向上转型时，编译器会直接将派生类对象的地址转换为基类对象的地址。
检查转换结果是否有效，如果无效，返回 NULL 或抛出 std::bad_cast 异常。例如，在向下转型时，如果源指针或引用指向的对象不是目标类型的对象，或者源指针或引用不是指向多态类型的指针或引用，转换就是无效的。"
带虚函数的指针在转换后地址值会有什么变化,
多继承子类的对象的内存布局,"https://zhuanlan.zhihu.com/p/369778659
类的成员中除了普通成员变量，其他的都不存储在对象的内存空间中，只存储在静态区。
内存：成员变量中的普通成员变量
静态区：成员变量中的静态成员变量；成员函数（静态函数，普通函数，虚函数）

一个子类继承多个父类的情况下：
按照父类的方式构造内存空间，两个父类，按照继承的顺序，从左至右。
基于之前的内存空间再构建属于Deliver独有的成员，比如说成员变量。
在父类对应的虚表内，用相同名字的虚函数的指针覆盖哪个父类的虚函数的指针。
在第一个虚表里面添加新加的虚函数指针。
"
除了锁、原子操作外，还有哪些措施来处理同步问题,"临界区
临界区 (Critical Section) 是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。
信号量
信号量是维护0到指定最大值之间的同步对象，用于线程的同步或者限制线程运行的数量。信号量状态在其计数大于0时是有信号的，而其计数是0时是无信号的。信号量对象在控制上可以支持有限数量共享资源的访问。
互斥量
windows下提供有互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。不过该互斥量和mutex基本一样，所以用移植性更好的mutex更好。"
const关键字,"A: const 修饰指针指向的内容，则内容为不可变量。在“*”左边
B: const 修饰指针，则指针为不可变量。在“*”右边
C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。"
指针,"int a = 8;
&a; a的地址
int* b; 一个整数型指针
*b; b里面的值"
面向对象编程思想,封装，继承和多态
多态,"在基类中使用virtual关键字来声明函数，可以在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
纯虚函数：在基类中又不能对虚函数给出有意义的实现，virtual int area() = 0;
"
虚拟内存,"结构：由高到低（命令和环境变量，stack， heap， uninintialized data, initialized data,text）

栈(Stack)：位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。（先进后出）
堆（Heap)：这里与C不同的是，该堆是由new申请的内存，由delete或delete[]负责释放。
自由存储区(Free Storage)：由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。
全局区/静态区(Global Static Area)： 全局变量和静态变量存放区，程序一经编译好，该区域便存在。在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了初始化变量和未初始化变量了（c中区分了），程序结束后由系统释放。
常量区： 这是一块比较特殊的存储区，专门存储不能修改的常量(一般是const修饰的变量，或是一些常量字符串)，程序结束后由系统释放。"
"glibc内存管理器,malloc,free",实际上glibc采用了一种批发和零售的方式来管理内存。glibc每次通过系统调用的方式申请一大块内存（虚拟内存），当进程申请内存时，glibc就从自己获得的内存中取出一块给进程。
设计模式,https://refactoringguru.cn/design-patterns/catalog
指针和引用的区别,"指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。
指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。
指针可以为 nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为 nullptr。
使用指针需要对其进行解引用以获取或修改其指向的变量的值；引用可以直接使用，无需解引用。"
#define和const区别,"（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。"
结构体（Struct）和类（Class）在C++中有哪些主要区别？,在C++中，结构体和类的主要区别在于默认的访问控制和继承权限。结构体的成员和基类默认是公开（public）的，而类的成员和基类默认是私有（private）的。除此之外，结构体和类在功能上几乎相同，都可以有成员函数、构造函数、析构函数等。
c++的类型,"1. 隐式类型转换
1.1 数值类型转换：从小整数类型(char、short)转换到int，或者从float转换到double
1.2 指针类型转换：空指针可以转换到任意指针类型；任意指针类型都可以转换到void* 指针；继承类指针可以转换到可访问的明确的基类指针， 同时不改变const或者volatile属性;

2. 显式类型转换
2.1 explicit关键字：阻止不应该允许的经过转换构造函数进行的隐式转换的发生。即声明为explicit的构造函数不能在隐式转换中使用。
2.1.1 static_cast：在编译时检查，但没有运行时类型检查来保证转换的安全性。
2.1.2 dynamic_cast：new_type 必须是一个指针或引用，dynamic_cast 会动用运行时信息（RTTI）来进行类型安全检查
2.1.3 const_cast：new_type 必须是一个指针、引用或者指向对象类型成员的指针。
2.1.4 reinterpret_cast： new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。"
传输层有哪些协议介绍一下,TCP UDP
死锁,"threadA，先获取DeadLock.LOCK_1，再获取DeadLock.LOCK_2
threadB，先获取DeadLock.LOCK_2，再获取DeadLock.LOCK_1

互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。"
进程通信,"管道(pipe)
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

有名管道 (namedpipe)
有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

信号量(semaphore)
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列(messagequeue)
消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号 (sinal)
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

共享内存(shared memory)
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

套接字(socket)
套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。"
线程间的通信方式,"锁机制：包括互斥锁、条件变量、读写锁
wait/notify 等待
Volatile 内存共享
CountDownLatch 并发工具
CyclicBarrier 并发工具

信号量机制(Semaphore)
包括无名线程信号量和命名线程信号量。

信号机制(Signal)
类似进程间的信号处理。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。"
new与malloc的区别,"new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。"
std::move(),显式地将左值转换为右值引用
vector内存分配方式,在调用push_back时，若当前容量已经不能够放入心得元素（capacity=size），那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。为了避免频繁的分配内存，C++每次申请内存都会成倍的增长。
